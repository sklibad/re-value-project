<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin=""/>
    <link rel="stylesheet" href="src/leaflet.legend.css" />
    <link rel="stylesheet" href="map1.css" />
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <script src="Control.FullScreen.js"></script>
    <script src="map1.js" type="text/javascript"></script>
    <script type="text/javascript" src="src/leaflet.legend.js"></script>
    <title>Map1</title>
</head>
<body>
    <div id="map"></div>
    <div id="additionalDropdownContainer"></div>
    <script type="text/javascript">
        var map = L.map('map', {
            fullscreenControl: true,
            fullscreenControlOptions: {
                title: "Show me the fullscreen !",
                titleCancel: "Exit fullscreen mode"
            }
        }).setView([62.62357822995269, 6.568337702605886], 9);

        var OSmap = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> | <a href="https://www.linkedin.com/in/david-skliba/?locale=en_US" target="_blank">David Šklíba</a>',
            opacity: 1
        }).addTo(map);

        var Imagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.arcgis.com/home/item.html?id=10df2279f9684e4a9f6a7f08febac2a9" target="_blank">ESRI</a> | <a href="https://www.linkedin.com/in/david-skliba/?locale=en_US" target="_blank">David Šklíba</a>',
            opacity: 1
        });

        var TopoMap = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href = "https://opentopomap.org/credits" target = "_blank">OpenTopoMap</a> | <a href="https://www.linkedin.com/in/david-skliba/?locale=en_US" target="_blank">David Šklíba</a>',
            opacity: 0.5
        });

        var baseLayers = {
            "OS Map": OSmap,
            "Imagery": Imagery,
            "TopoMap": TopoMap
        };

        var alesund = L.geoJSON(alesund, {
            style: function (feature) {
                return {
                    fillColor: "#C0C0C0",
                    fillOpacity: 0,
                    color: '#808080',
                    weight: 3
                };
            }
        });

        var bruges = L.geoJSON(bruges, {
            style: function (feature) {
                return {
                    fillColor: "#C0C0C0",
                    fillOpacity: 0,
                    color: '#808080',
                    weight: 3
                };
            }
        });

        var burgas = L.geoJSON(burgas, {
            style: function (feature) {
                return {
                    fillColor: "#C0C0C0",
                    fillOpacity: 0,
                    color: '#808080',
                    weight: 3
                };
            }
        });

        var cascais = L.geoJSON(cascais, {
            style: function (feature) {
                return {
                    fillColor: "#C0C0C0",
                    fillOpacity: 0,
                    color: '#808080',
                    weight: 3
                };
            }
        });

        var constanta = L.geoJSON(constanta, {
            style: function (feature) {
                return {
                    fillColor: "#C0C0C0",
                    fillOpacity: 0,
                    color: '#808080',
                    weight: 3
                };
            }
        });

        var izmir = L.geoJSON(izmir, {
            style: function (feature) {
                return {
                    fillColor: "#C0C0C0",
                    fillOpacity: 0,
                    color: '#808080',
                    weight: 3
                };
            }
        });

        var pisek = L.geoJSON(pisek, {
            style: function (feature) {
                return {
                    fillColor: "#C0C0C0",
                    fillOpacity: 0,
                    color: '#808080',
                    weight: 3
                };
            }
        });

        var rijeka = L.geoJSON(rijeka, {
            style: function (feature) {
                return {
                    fillColor: "#C0C0C0",
                    fillOpacity: 0,
                    color: '#808080',
                    weight: 3
                };
            }
        });

        var rimini = L.geoJSON(rimini, {
            style: function (feature) {
                return {
                    fillColor: "#C0C0C0",
                    fillOpacity: 0,
                    color: '#808080',
                    weight: 3
                };
            }
        });

        var overlayLayers = {
            "Alesund": alesund,
            "Cascais": cascais,
            "Bruges": bruges,
            "Burgas": burgas,
            "Constanta": constanta,
            "Izmir": izmir,
            "Pisek": pisek,
            "Rijeka": rijeka,
            "Rimini": rimini
        };

        // Add the initial radio button layer
        overlayLayers[Object.keys(overlayLayers)[0]].addTo(map);

        // Define the dictionary for coordinates and zoom levels
        var layerViewSettings = {
            "Alesund": { center: [62.62357822995269, 6.568337702605886], zoom: 9 },
            "Cascais": { center: [38.7246415419252, -9.398661627395064], zoom: 12 },
            "Bruges": { center: [51.26277668564624, 3.2157520267962854], zoom: 11 },
            "Burgas": { center: [42.52365465796975, 27.412133356605594], zoom: 10 },
            "Constanta": { center: [44.18397145865716, 28.595090491839358], zoom: 11 },
            "Izmir": { center: [38.60497560030166, 27.446486886485193], zoom: 8 },
            "Pisek": { center: [49.28765927177321, 14.167823590584321], zoom: 12 },
            "Rijeka": { center: [44.97243541294297, 14.623684506249385], zoom: 8 },
            "Rimini": { center: [43.96190532408524, 12.423399060233246], zoom: 10 }
        };

        async function fetchExtents(path) {
            try {
                const response = await fetch(path);
                const extents = await response.json();
                return extents;
            } catch (error) {
                console.error('Error fetching extents:', error);
                return {};
            }
        }

        let currentOverlay = null;

        async function updateMapWithPng(path, pngFileName) {
            if (currentOverlay) {
                map.removeLayer(currentOverlay);
            }

            const extents = await fetchExtents(`${path}/extents.json`);
            const extent = extents[`${pngFileName}`];
            console.log(extent)
            if (extent) {
                currentOverlay = L.imageOverlay(`${path}/${pngFileName}.png`, extent).addTo(map);
                map.fitBounds(extent);

                // Apply CSS styling to render the image as pixelated
                currentOverlay.getElement().style.imageRendering = 'pixelated';
            }
        }


        async function fetchFolders(path) {
            const url = `${path}/`;
            console.log('Fetching folders from URL:', url); // Debug log
            try {
                const response = await fetch(url);
                const responseText = await response.text();
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    if (contentType.includes('text/html')) {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(responseText, 'text/html');
                        const links = Array.from(doc.querySelectorAll('a'));
                        const folders = links
                            .map(link => link.textContent)
                            .filter(name => name.endsWith('/'))
                            .map(name => name.slice(0, -1));
                        return folders;
                    } else {
                        throw new Error(`Expected JSON or HTML response, but received: ${contentType}`);
                    }
                }
                const folders = JSON.parse(responseText);
                return folders;
            } catch (error) {
                console.error('Error fetching or parsing folders:', error);
                return [];
            }
        }

        async function fetchFiles(path) {
            const url = `${path}/`;
            console.log('Fetching files from URL:', url); // Debug log
            try {
                const response = await fetch(url);
                const responseText = await response.text();
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    if (contentType.includes('text/html')) {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(responseText, 'text/html');
                        const links = Array.from(doc.querySelectorAll('a'));
                        const files = links.map(link => link.textContent);
                        return files;
                    } else {
                        throw new Error(`Expected JSON or HTML response, but received: ${contentType}`);
                    }
                }
                const files = JSON.parse(responseText);
                return files;
            } catch (error) {
                console.error('Error fetching or parsing files:', error);
                return [];
            }
        }



        async function updateFolderDropdown(layerName) {
            const folders = await fetchFolders(layerName);
            const dropdown = document.getElementById('folderDropdown');
            updateDropdownOptions(dropdown, folders, 'Select a category');
        }

        document.addEventListener('DOMContentLoaded', function () {
            updateFolderDropdown(Object.keys(overlayLayers)[0]);
        });



        async function updateFileOrSubcategoryDropdown(path) {
            const files = await fetchFiles(path);
            const pngFiles = files.filter(file => file.endsWith('.png'));
            const subfolders = files.filter(file => file.endsWith('/')).map(name => name.slice(0, -1));

            const container = document.getElementById('additionalDropdownContainer');
            container.innerHTML = '';

            const label = document.createElement('div');
            label.textContent = pngFiles.length > 0 ? 'Data' : 'Subcategory';
            label.style.marginTop = '10px'; // Add some margin for spacing
            container.appendChild(label);

            const dropdown = document.createElement('select');
            dropdown.id = 'additionalDropdown';

            if (pngFiles.length > 0) {
                updateDropdownOptions(dropdown, pngFiles, 'Select an option');
            } else {
                updateDropdownOptions(dropdown, subfolders, 'Select a subcategory');
            }

            container.appendChild(dropdown);

            if (subfolders.length > 0) {
                dropdown.addEventListener('change', function () {
                    const selectedSubfolder = this.value;
                    if (selectedSubfolder) {
                        updatePngFilesDropdown(`${path}/${selectedSubfolder}`);
                    }
                });
            }
        }

        function updateDropdownOptions(dropdown, options, title) {
            dropdown.innerHTML = `<option value="">${title}</option>`;
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option.endsWith('.png') ? option.slice(0, -4) : option; // Remove ".png" suffix
                dropdown.appendChild(opt);
            });
        }


        async function updatePngFilesDropdown(path) {
            const files = await fetchFiles(path);
            const pngFiles = files.filter(file => file.endsWith('.png'));

            const container = document.getElementById('pngFilesDropdownContainer');
            if (!container) {
                const newContainer = document.createElement('div');
                newContainer.id = 'pngFilesDropdownContainer';
                newContainer.style.marginTop = '10px';

                const label = document.createElement('div');
                label.textContent = 'Data';
                newContainer.appendChild(label);

                const dropdown = document.createElement('select');
                dropdown.id = 'pngFilesDropdown';
                updateDropdownOptions(dropdown, pngFiles.map(file => file.slice(0, -4)), 'Select data');

                dropdown.addEventListener('change', function () {
                    const selectedPngFile = this.value;
                    if (selectedPngFile) {
                        updateMapWithPng(path, selectedPngFile);
                    }
                });

                newContainer.appendChild(dropdown);
                document.getElementById('additionalDropdownContainer').appendChild(newContainer);
            } else {
                container.innerHTML = '';
                const label = document.createElement('div');
                label.textContent = 'Data';
                container.appendChild(label);

                const dropdown = document.createElement('select');
                dropdown.id = 'pngFilesDropdown';
                updateDropdownOptions(dropdown, pngFiles.map(file => file.slice(0, -4)), 'Select data');

                dropdown.addEventListener('change', function () {
                    const selectedPngFile = this.value;
                    if (selectedPngFile) {
                        updateMapWithPng(path, selectedPngFile);
                    }
                });

                container.appendChild(dropdown);
            }
        }

        // Example usage:
        document.addEventListener('DOMContentLoaded', function () {
            updateFolderDropdown(Object.keys(overlayLayers)[0]);
        });


        var overlayControl = L.control({ position: 'topright' });

        overlayControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend');
            div.style.backgroundColor = 'white';
            div.style.padding = '10px';
            div.style.border = '2px solid #ccc';
            div.style.borderRadius = '5px';

            for (var i = 0; i < Object.keys(overlayLayers).length; i++) {
                var layerName = Object.keys(overlayLayers)[i];
                var checkedAttribute = i === 0 ? 'checked' : '';

                div.innerHTML +=
                    '<input type="radio" name="layer" value="' + layerName + '" id="' + layerName + '" ' + checkedAttribute +
                    ' title="Switch to ' + layerName + '">' +
                    '<label for="' + layerName + '" title="Switch to ' + layerName + '">' + layerName + '</label><br>';
            }

            div.innerHTML += '<br><label for="folderDropdown">Category:</label><br>';
            var select = L.DomUtil.create('select', '', div);
            select.id = 'folderDropdown';
            select.innerHTML = '<option value="">Select a category</option>';

            select.addEventListener('change', function () {
                const selectedOption = this.value;
                const selectedLayer = document.querySelector('input[name="layer"]:checked').value;
                const path = `${selectedLayer}/${selectedOption}`;
                updateFileOrSubcategoryDropdown(path);
            });

            div.addEventListener('change', function (e) {
                if (e.target.name === 'layer') {
                    var selectedLayer = e.target.value;

                    for (var layerName in overlayLayers) {
                        if (overlayLayers.hasOwnProperty(layerName) && layerName !== selectedLayer) {
                            map.removeLayer(overlayLayers[layerName]);
                        }
                    }
                    overlayLayers[selectedLayer].addTo(map);

                    if (layerViewSettings[selectedLayer]) {
                        map.setView(layerViewSettings[selectedLayer].center, layerViewSettings[selectedLayer].zoom);
                    }

                    updateFolderDropdown(selectedLayer);
                }
            });

            var additionalDropdownContainer = L.DomUtil.create('div', '', div);
            additionalDropdownContainer.id = 'additionalDropdownContainer';
            additionalDropdownContainer.style.marginTop = '10px'; // Add some margin for spacing

            return div;
        };




        L.control.layers(baseLayers).addTo(map);
        overlayControl.addTo(map);
        updateFolderDropdown(Object.keys(overlayLayers)[0]);

    </script>
</body>
</html>
