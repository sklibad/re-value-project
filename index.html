<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin=""/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="src/leaflet.legend.css" />
    <link rel="stylesheet" href="map1.css?v=1.1" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="Control.FullScreen.js"></script>
    <script src="map1.js?v=1.1" type="text/javascript"></script>
    <script type="text/javascript" src="src/leaflet.legend.js"></script>
    <title>Map1</title>
</head>
<body>
    <div id="map"></div>
    <div id="popup" class="popup">
        <label for="opacitySlider">Opacity:</label>
        <input type="range" id="opacitySlider" min="0" max="1" step="0.01">
    </div>
    <script type="text/javascript">
        var map = L.map('map', {
            fullscreenControl: true,
            fullscreenControlOptions: {
                title: "Show me the fullscreen !",
                titleCancel: "Exit fullscreen mode"
            }
        }).setView([62.62357822995269, 6.568337702605886], 9);

        var OSmap = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> | <a href="https://www.linkedin.com/in/david-skliba/?locale=en_US" target="_blank">David Šklíba</a>',
            opacity: 0.5
        }).addTo(map);

        var Imagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.arcgis.com/home/item.html?id=10df2279f9684e4a9f6a7f08febac2a9" target="_blank">ESRI</a> | <a href="https://www.linkedin.com/in/david-skliba/?locale=en_US" target="_blank">David Šklíba</a>',
            opacity: 1
        });

        var TopoMap = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href = "https://opentopomap.org/credits" target = "_blank">OpenTopoMap</a> | <a href="https://www.linkedin.com/in/david-skliba/?locale=en_US" target="_blank">David Šklíba</a>',
            opacity: 0.5
        });

        var baseLayers = {
            "OS Map": OSmap,
            "Imagery": Imagery,
            "TopoMap": TopoMap
        };

        var overlayLayers = {
            "Alesund": L.geoJSON(alesund, { style: getGeoJsonStyle() }),
            "Cascais": L.geoJSON(cascais, { style: getGeoJsonStyle() }),
            "Bruges": L.geoJSON(bruges, { style: getGeoJsonStyle() }),
            "Burgas": L.geoJSON(burgas, { style: getGeoJsonStyle() }),
            "Constanta": L.geoJSON(constanta, { style: getGeoJsonStyle() }),
            "Izmir": L.geoJSON(izmir, { style: getGeoJsonStyle() }),
            "Pisek": L.geoJSON(pisek, { style: getGeoJsonStyle() }),
            "Rijeka": L.geoJSON(rijeka, { style: getGeoJsonStyle() }),
            "Rimini": L.geoJSON(rimini, { style: getGeoJsonStyle() })
        };

        overlayLayers[Object.keys(overlayLayers)[0]].addTo(map)

        function getGeoJsonStyle() {
            return {
                fillColor: "#C0C0C0",
                fillOpacity: 0,
                color: '#808080',
                weight: 3
            };
        }

        var layerViewSettings = {
            "Alesund": { center: [62.62357822995269, 6.568337702605886], zoom: 9 },
            "Cascais": { center: [38.7246415419252, -9.398661627395064], zoom: 12 },
            "Bruges": { center: [51.26277668564624, 3.2157520267962854], zoom: 11 },
            "Burgas": { center: [42.52365465796975, 27.412133356605594], zoom: 10 },
            "Constanta": { center: [44.18397145865716, 28.595090491839358], zoom: 11 },
            "Izmir": { center: [38.4274666702251, 27.15412241220643], zoom: 11 },
            "Pisek": { center: [49.28765927177321, 14.167823590584321], zoom: 12 },
            "Rijeka": { center: [45.338554885503896, 14.424501967276987], zoom: 12 },
            "Rimini": { center: [44.05320342546707, 12.56987993983287], zoom: 13 }
        };

        let activeLayers = {};

        async function fetchExtents(path) {
            try {
                const response = await fetch(path);
                const extents = await response.json();
                return extents;
            } catch (error) {
                console.error('Error fetching extents:', error);
                return {};
            }
        }

        async function updateMapWithPng(path, subcategory, pngFileName) {
            const extents = await fetchExtents(`${path}/extents.json`);
            const extent = extents[pngFileName];

            if (extent) {
                const layer = L.imageOverlay(`${path}/${pngFileName}.png`, extent).addTo(map);

                layer.getElement().style.imageRendering = 'pixelated';

                const layerName = `${subcategory} - ${pngFileName}`;
                activeLayers[layerName] = layer; // Directly store the layer
                updateActiveLayersPanel();
            }
        }

        function toggleLayer(layerName, isChecked) {
            const { layer } = activeLayers[layerName];
            if (isChecked) {
                layer.addTo(map);
            } else {
                removeLayer(layerName);
            }
        }

        function removeLayer(layerName) {
            console.log(activeLayers)
            if (activeLayers[layerName]) {
                map.removeLayer(activeLayers[layerName].layer);
                updateActiveLayersPanel();
            }
            console.log(activeLayers)
        }

        function removeAllActiveLayers() {
            Object.keys(activeLayers).forEach(layerName => {
                removeLayer(layerName);
            });
        }

        // Function to show popup for opacity control
        function showPopup(event, layerName) {
            const popup = document.getElementById('popup');
            popup.style.display = 'block';
            popup.style.top = `${event.clientY + 5}px`;
            popup.style.left = `${event.clientX - popup.offsetWidth}px`;
            const slider = document.getElementById('opacitySlider');

            slider.oninput = function () {
                const value = this.value;
                const layer = activeLayers[layerName];

                if (layer instanceof L.GeoJSON) {
                    layer.eachLayer(function (featureLayer) {
                        if (featureLayer.setStyle) {
                            featureLayer.setStyle({ opacity: value, fillOpacity: value });
                        }
                    });
                } else if (layer instanceof L.ImageOverlay) {
                    layer.setOpacity(value);
                }
            };

            const layer = activeLayers[layerName];
            if (layer instanceof L.GeoJSON) {
                slider.value = layer.options.style ? layer.options.style.opacity || 1 : 1;
            } else if (layer instanceof L.ImageOverlay) {
                slider.value = layer.options.opacity || 1;
            }
        }

        // Function to hide the popup
        function hidePopup() {
            const popup = document.getElementById('popup');
            popup.style.display = 'none';
        }

        async function fetchFolders(path) {
            try {
                const response = await fetch(path);
                const responseText = await response.text();
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    if (contentType.includes('text/html')) {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(responseText, 'text/html');
                        const links = Array.from(doc.querySelectorAll('a'));
                        const folders = links
                            .map(link => link.textContent)
                            .filter(name => name.endsWith('/'))
                            .map(name => name.slice(0, -1));
                        return folders;
                    } else {
                        throw new Error(`Expected JSON or HTML response, but received: ${contentType}`);
                    }
                }
                const folders = JSON.parse(responseText);
                return folders;
            } catch (error) {
                console.error('Error fetching or parsing folders:', error);
                return [];
            }
        }

        async function fetchFiles(path) {
            try {
                const response = await fetch(path);
                const responseText = await response.text();
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    if (contentType.includes('text/html')) {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(responseText, 'text/html');
                        const links = Array.from(doc.querySelectorAll('a'));
                        const files = links.map(link => link.textContent);
                        return files;
                    } else {
                        throw new Error(`Expected JSON or HTML response, but received: ${contentType}`);
                    }
                }
                const files = JSON.parse(responseText);
                return files;
            } catch (error) {
                console.error('Error fetching or parsing files:', error);
                return [];
            }
        }

        function updateDropdownOptions(dropdown, options, title) {
            dropdown.innerHTML = `<option value="">${title}</option>`;
            options.forEach(option => {
                const opt = document.createElement('option');
                opt.value = option;
                opt.textContent = option.endsWith('.png') ? option.slice(0, -4) : option;
                dropdown.appendChild(opt);
            });
        }

        async function updateFolderDropdown(layerName) {
            const folders = await fetchFolders(`${layerName}`);
            const dropdown = document.getElementById('folderDropdown');
            updateDropdownOptions(dropdown, folders, 'Select a category');
        }

        async function updateFileOrSubcategoryDropdown(path) {
            const files = await fetchFiles(path);
            const pngFiles = files.filter(file => file.endsWith('.png'));
            const subfolders = files.filter(file => file.endsWith('/')).map(name => name.slice(0, -1));

            const container = document.getElementById('additionalDropdownContainer');
            container.innerHTML = '';

            const label = document.createElement('div');
            label.textContent = pngFiles.length > 0 ? 'Data' : 'Subcategory';
            label.style.marginTop = '10px';
            container.appendChild(label);

            const dropdown = document.createElement('select');
            dropdown.id = 'additionalDropdown';

            if (pngFiles.length > 0) {
                updateDropdownOptions(dropdown, pngFiles, 'Select an option');
            } else {
                updateDropdownOptions(dropdown, subfolders, 'Select a subcategory');
            }

            container.appendChild(dropdown);

            if (subfolders.length > 0) {
                dropdown.addEventListener('change', function () {
                    const selectedSubfolder = this.value;
                    if (selectedSubfolder) {
                        updatePngFilesDropdown(`${path}/${selectedSubfolder}`);
                    }
                });
            }

            updateActiveLayersPanel();
        }

        async function updatePngFilesDropdown(path) {
            const files = await fetchFiles(path);
            const pngFiles = files.filter(file => file.endsWith('.png'));

            const container = document.getElementById('pngFilesDropdownContainer');
            container.innerHTML = ''; // Clear previous content

            const label = document.createElement('div');
            label.textContent = 'Data';
            container.appendChild(label);

            const dropdown = document.createElement('select');
            dropdown.id = 'pngFilesDropdown';
            updateDropdownOptions(dropdown, pngFiles.map(file => file.slice(0, -4)), 'Select data');

            dropdown.addEventListener('change', function () {
                const selectedPngFile = this.value;
                if (selectedPngFile) {
                    const subcategory = document.getElementById('additionalDropdown').value;
                    updateMapWithPng(path, subcategory, selectedPngFile);
                }
            });

            container.appendChild(dropdown);

            updateActiveLayersPanel();
        }

        var overlayControl = L.control({ position: 'topright' });

        overlayControl.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'info legend section-container');
            div.style.backgroundColor = 'white';
            div.style.padding = '10px';
            div.style.border = '2px solid #ccc';
            div.style.borderRadius = '5px';

            for (var i = 0; i < Object.keys(overlayLayers).length; i++) {
                var layerName = Object.keys(overlayLayers)[i];
                var checkedAttribute = i === 0 ? 'checked' : '';

                div.innerHTML +=
                    '<input type="radio" name="layer" value="' + layerName + '" id="' + layerName + '" ' + checkedAttribute +
                    ' title="Switch to ' + layerName + '">' +
                    '<label for="' + layerName + '" title="Switch to ' + layerName + '">' + layerName + '</label><br>';
            }

            div.innerHTML += '<br><label for="folderDropdown">Category:</label><br>';
            var select = L.DomUtil.create('select', '', div);
            select.id = 'folderDropdown';
            select.innerHTML = '<option value="">Select a category</option>';

            select.addEventListener('change', function () {
                const selectedOption = this.value;
                const selectedLayer = document.querySelector('input[name="layer"]:checked').value;
                const path = `${selectedLayer}/${selectedOption}`;
                updateFileOrSubcategoryDropdown(path);
            });

            div.addEventListener('change', function (e) {
                if (e.target.name === 'layer') {
                    var selectedLayer = e.target.value;

                    for (var layerName in overlayLayers) {
                        if (overlayLayers.hasOwnProperty(layerName) && layerName !== selectedLayer) {
                            map.removeLayer(overlayLayers[layerName]);
                        }
                    }
                    overlayLayers[selectedLayer].addTo(map);

                    if (layerViewSettings[selectedLayer]) {
                        map.setView(layerViewSettings[selectedLayer].center, layerViewSettings[selectedLayer].zoom);
                    }

                    removeAllActiveLayers();
                    activeLayers = {};
                    updateFolderDropdown(selectedLayer);
                    document.getElementById('activeLayersList').innerHTML = ''; // Clear active layers panel
                    document.getElementById('additionalDropdownContainer').innerHTML = ''; // Clear subcategory dropdown
                    document.getElementById('pngFilesDropdownContainer').innerHTML = ''; // Clear data dropdown
                }
            });

            // Add the file upload button above the Active Layers section
            var fileUploadContainer = L.DomUtil.create('div', '', div);
            fileUploadContainer.style.marginTop = '10px';

            var fileUploadButton = L.DomUtil.create('input', '', fileUploadContainer);
            fileUploadButton.type = 'file';
            fileUploadButton.accept = '.geojson';
            fileUploadButton.style.width = '100%';

            fileUploadButton.addEventListener('change', function (event) {
                var file = event.target.files[0];
                if (file) {
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        var geojson = JSON.parse(e.target.result);
                        var layer = L.geoJSON(geojson, { style: getGeoJsonStyle() }).addTo(map);
                        const bounds = layer.getBounds();
                        map.fitBounds(bounds); 
                        const layerName = `${file.name.slice(0, -8)}`;
                        activeLayers[layerName] = layer;
                        updateActiveLayersPanel();
                    };
                    reader.readAsText(file);
                }
            });

            var additionalDropdownContainer = L.DomUtil.create('div', '', div);
            additionalDropdownContainer.id = 'additionalDropdownContainer';
            additionalDropdownContainer.style.marginTop = '10px';

            var pngFilesDropdownContainer = L.DomUtil.create('div', '', div);
            pngFilesDropdownContainer.id = 'pngFilesDropdownContainer';
            pngFilesDropdownContainer.style.marginTop = '10px';

            var activeLayersContainer = L.DomUtil.create('div', '', div);
            activeLayersContainer.id = 'activeLayersContainer';
            activeLayersContainer.style.marginTop = '10px';

            var activeLayersHeader = L.DomUtil.create('h4', '', activeLayersContainer);
            activeLayersHeader.textContent = 'Active Layers';

            var activeLayersList = L.DomUtil.create('div', '', activeLayersContainer);
            activeLayersList.id = 'activeLayersList';

            div.appendChild(additionalDropdownContainer);
            div.appendChild(pngFilesDropdownContainer);
            div.appendChild(activeLayersContainer);
            div.appendChild(fileUploadContainer);

            return div;
        };

        const popup = document.getElementById('popup');
        popup.onmouseover = function () {
            popup.style.display = 'block';
        };
        popup.onmouseout = function () {
            popup.style.display = 'none';
        };

        L.control.layers(baseLayers).addTo(map);
        overlayControl.addTo(map);
        updateFolderDropdown(Object.keys(overlayLayers)[0]);


        // Add a custom button to create a new object
        L.Control.NewObjectControl = L.Control.extend({
            onAdd: function(map) {
                var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
                container.title = 'Create New Object';

                var link = L.DomUtil.create('a', 'leaflet-draw-edit-remove', container);
                link.href = '#';
                link.innerHTML = '<i class="fa-solid fa-square-plus"></i>'; // Using Font Awesome icon

                L.DomEvent.on(container, 'click', function (e) {
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);
                    createNewObject();
                });

                return container;
            }
        });

        function createNewObject() {
            multipartGeoJSON = {
                "type": "FeatureCollection",
                "features": []
            };

            if (multipartLayer) {
                //map.removeLayer(multipartLayer);
            }

            multipartLayer = L.geoJSON(multipartGeoJSON, { style: getGeoJsonStyle() }).addTo(map);

            const layerName = `Multipart Layer ${Object.keys(activeLayers).length + 1}`;
            activeLayers[layerName] = multipartLayer;
            currentLayerName = layerName; // Set the current layer name to the new layer
            updateActiveLayersPanel();
        }

        // Add the custom control to the map
        map.addControl(new L.Control.NewObjectControl({ position: 'topleft' }));

        // Add Leaflet Draw controls
        var drawnLayers = [];

        var multipartGeoJSON = {
            "type": "FeatureCollection",
            "features": []
        };

        // Initialize multipartLayer but do not add to map or activeLayers initially
        var multipartLayer = L.geoJSON(multipartGeoJSON, { style: getGeoJsonStyle() });
        var currentLayerName = '';

        var drawControl = new L.Control.Draw({
            draw: {
                polygon: true,
                polyline: true,
                rectangle: true,
                circle: false,
                marker: true,
                circlemarker: false
            }
        });
        map.addControl(drawControl);

        // Handle the creation of drawn items
        map.on(L.Draw.Event.CREATED, function (event) {
            var layer = event.layer;
            var newFeature = layer.toGeoJSON();

            // Add new feature to the current multipartGeoJSON
            multipartGeoJSON.features.push(newFeature);

            // Add new feature to the existing multipartLayer
            multipartLayer.addData(newFeature);

            // Add the drawn layer to the drawnLayers list
            drawnLayers.push(layer);

            // Ensure the layer is editable
            layer.on('click', function () {
                new L.EditToolbar.Edit(map, {
                    featureGroup: new L.FeatureGroup([layer])
                }).enable();
            });

            // Ensure the active layers panel is up-to-date
            updateActiveLayersPanel();
        });

        // Function to update active layers panel
        function updateActiveLayersPanel() {
            const activeLayersList = document.getElementById('activeLayersList');
            activeLayersList.innerHTML = '';
            Object.keys(activeLayers).forEach(layerName => {
                const div = document.createElement('div');

                // Create a checkbox to toggle layer visibility
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = map.hasLayer(activeLayers[layerName]);
                checkbox.onchange = function () {
                    toggleLayer(layerName, this.checked);
                };

                // Create a label for the layer name
                const layerLabel = document.createElement('span');
                layerLabel.textContent = layerName;
                layerLabel.onmouseover = function (e) {
                    showPopup(e, layerName);
                };
                layerLabel.onmouseout = hidePopup;

                // Add double-click event for renaming the layer
                layerLabel.ondblclick = function () {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = layerName;
                    input.onblur = function () {
                        const newLayerName = input.value.trim();
                        if (newLayerName && newLayerName !== layerName) {
                            activeLayers[newLayerName] = activeLayers[layerName];
                            delete activeLayers[layerName];
                            updateActiveLayersPanel();
                        }
                    };
                    input.onkeydown = function (e) {
                        if (e.key === 'Enter') {
                            input.blur();
                        }
                    };
                    div.replaceChild(input, layerLabel);
                    input.focus();
                };

                // Create a delete button with Font Awesome trash icon
                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = '<i class="fa fa-trash"></i>'; // Using Font Awesome trash icon
                deleteButton.onclick = function () {
                    deleteLayer(layerName);
                };
                deleteButton.style.background = 'none';
                deleteButton.style.border = 'none';
                deleteButton.style.cursor = 'pointer';
                deleteButton.style.color = 'red';

                div.appendChild(checkbox);
                div.appendChild(layerLabel);
                div.appendChild(deleteButton);
                activeLayersList.appendChild(div);
            });
        }

        // Function to toggle layer visibility
        function toggleLayer(layerName, isChecked) {
            const layer = activeLayers[layerName];
            if (isChecked) {
                layer.addTo(map);
            } else {
                map.removeLayer(layer);
            }
        }

        // Function to delete a layer
        function deleteLayer(layerName) {
            const layer = activeLayers[layerName];
            if (layer) {
                map.removeLayer(layer);
                delete activeLayers[layerName];
                updateActiveLayersPanel();
            }
        }

    </script>
</body>
</html>
